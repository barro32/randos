import { describe, it, expect, vi } from 'vitest';
import { items, Item } from './items'; // Adjust path as necessary
import { Player } from './player'; // Adjust path as necessary

// Mock Player class
vi.mock('./player', () => {
    const Player = vi.fn();
    Player.prototype.increaseDamage = vi.fn();
    Player.prototype.increaseDefense = vi.fn();
    Player.prototype.increaseGoldPerHit = vi.fn();
    Player.prototype.heal = vi.fn();
    Player.prototype.increaseSpeed = vi.fn();
    Player.prototype.increaseMaxHealth = vi.fn();
    Player.prototype.addGold = vi.fn();
    // Mock other player methods if items.ts uses them
    return { Player };
});


describe('Shop Items', () => {
    let mockPlayer: Player;

    beforeEach(() => {
        // Reset mocks before each test
        vi.clearAllMocks();
        // Create a new instance of the mocked Player for each test
        // We can't directly instantiate a vi.fn(), so we use a constructor mock approach
        // or rely on the prototype mocks if direct instantiation isn't needed for the test.
        // For 'applyEffect', we pass an object that matches the expected Player structure.
        mockPlayer = {
            increaseDamage: vi.fn(),
            increaseDefense: vi.fn(),
            increaseGoldPerHit: vi.fn(),
            heal: vi.fn(),
            increaseSpeed: vi.fn(),
            increaseMaxHealth: vi.fn(),
            addGold: vi.fn(),
            // Ensure all methods called by items are mocked here
        } as unknown as Player; // Type assertion
    });

    Object.entries(items).forEach(([key, item]) => {
        describe(`Item: ${item.name}`, () => {
            it('should have correct properties', () => {
                expect(item.name).toBeTypeOf('string');
                expect(item.description).toBeTypeOf('string');
                expect(item.icon).toBeTypeOf('string');
                expect(item.cost).toBeTypeOf('number');
                expect(item.cost).toBeGreaterThanOrEqual(0);
                expect(item.applyEffect).toBeTypeOf('function');
            });

            it('should apply its effect to the player', () => {
                item.applyEffect(mockPlayer);

                switch (key) {
                    case 'sword':
                        expect(mockPlayer.increaseDamage).toHaveBeenCalledWith(5);
                        break;
                    case 'shield':
                        expect(mockPlayer.increaseDefense).toHaveBeenCalledWith(5);
                        break;
                    case 'goldMagnet':
                        expect(mockPlayer.increaseGoldPerHit).toHaveBeenCalledWith(1);
                        break;
                    case 'healthPotion':
                        expect(mockPlayer.heal).toHaveBeenCalledWith(20);
                        break;
                    case 'bootsOfSpeed':
                        expect(mockPlayer.increaseSpeed).toHaveBeenCalledWith(10);
                        break;
                    case 'amuletOfVitality':
                        expect(mockPlayer.increaseMaxHealth).toHaveBeenCalledWith(25);
                        break;
                    case 'luckyCharm':
                        expect(mockPlayer.addGold).toHaveBeenCalledWith(5);
                        break;
                    case 'vampiricBlade':
                        expect(mockPlayer.increaseDamage).toHaveBeenCalledWith(3);
                        expect(mockPlayer.increaseGoldPerHit).toHaveBeenCalledWith(1);
                        break;
                    case 'titansBelt':
                        expect(mockPlayer.increaseMaxHealth).toHaveBeenCalledWith(15);
                        expect(mockPlayer.increaseDefense).toHaveBeenCalledWith(3);
                        break;
                    default:
                        // This case should not be reached if all items are handled
                        // Or, if some items have no direct effect mockPlayer call, this is fine.
                        break;
                }
            });
        });
    });

    it('should ensure all defined items are tested', () => {
        const itemKeys = Object.keys(items);
        // This is a meta-test to ensure we don't forget to add tests when new items are added.
        // It assumes that each item will have a describe block generated by the Object.entries().forEach loop.
        // The number of `describe` calls for items can be a bit tricky to count directly,
        // so we'll just check if all item keys were iterated.
        // A more robust check might involve inspecting the test report or using a custom reporter,
        // but for now, this confirms the loop runs for all items.
        expect(itemKeys.length).toBeGreaterThan(0); // Basic check that items exist
    });
});
